<!DOCTYPE html>

<html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Asincron铆a en JavaScript</title>
    </head>

    <body>
        <h1>ASINCRONA EN JAVASCRIPT</h1>
        
        <h2>Asincron铆a</h2>

        <p><pre>
            La asincron铆a es uno de los pilares fundamentales de Javascript,
            ya que es un lenguaje de programaci贸n de un s贸lo subproceso o hilo (single thread),
            lo que significa que s贸lo puede ejecutar una cosa a la vez.

Si bien los idiomas de un s贸lo hilo simplifican la escritura de c贸digo porque no tiene que
preocuparse por los problemas de concurrencia, esto tambi茅n significa que no puede realizar 
operaciones largas como el acceso a la red sin bloquear el hilo principal.

Imagina que solicitas datos de una API. Dependiendo de la situaci贸n, el servidor puede tardar 
un tiempo en procesar la solicitud mientras bloquea el hilo principal y hace que la p谩gina web no responda.

Ah铆 es donde entra en juego la asincron铆a que permite realizar largas solicitudes de red sin 
bloquear el hilo principal.

JavaScript fue dise帽ado para ser ejecutado en navegadores, trabajar con peticiones sobre la 
red y procesar las interacciones de usuario, al tiempo que mantiene una interfaz fluida.

Javascript usa un modelo as铆ncrono y no bloqueante, con un loop de eventos implementado en un 
s贸lo hilo, (single thread) para operaciones de entrada y salida (input/output).

Gracias a esta soluci贸n, Javascript es 谩ltamente concurrente a pesar de emplear un s贸lo hilo.
        </pre></p>

        <h2>Temporizadores: setTimeout y setInterval</h2>
        

        <p><pre>
            El m茅todo global <b><i> setTimeout()</i></b> establece un temporizador que ejecuta una funci贸n o 
            una pieza de c贸digo espec铆fica una vez que expira el temporizador.
            
            <br>
            <b><i>El setInterval()</i></b>m茅todo, que se ofrece en las interfaces Windowy Worker,
            llama repetidamente a una funci贸n o ejecuta un fragmento de c贸digo,
            con un retraso de tiempo fijo entre cada llamada.

        Este m茅todo devuelve un ID de intervalo que identifica de forma exclusiva el intervalo,
        por lo que puede eliminarlo m谩s tarde llamando a clearInterval().
        </pre></p>

        <h2> Funci贸n Asincrona</h2>
        <p><pre>
        <b><i>Una funci贸n as铆ncrona</i></b> es una funci贸n declarada con la asyncpalabra clave,
            y la awaitpalabra clave est谩 permitida dentro de ella.
            Las palabras clave asyncy awaitpermiten que el comportamiento as铆ncrono basado en promesas
            se escriba en un estilo m谩s limpio, evitando la necesidad de configurar expl铆citamente cadenas de promesas.

        Las funciones as铆ncronas tambi茅n se pueden definir como expresiones .
        </pre></p>


        <h2>Callbacks</h2>
        <p><pre>
            Una funci贸n de devoluci贸n de llamada es una funci贸n que se pasa a otra funci贸n como argumento,
            que luego se invoca dentro de la funci贸n externa para completar alg煤n tipo de rutina o acci贸n.
        </pre></p>

        <h2>Promises</h2>
        <p><pre>
            El Promise objeto representa la eventual finalizaci贸n (o falla) de una operaci贸n asincr贸nica y su valor resultante.

    Para conocer c贸mo funcionan las promesas y c贸mo puede usarlas, le recomendamos que lea primero Uso de promesas .

    <h3>Descripci贸n</h3>
        A Promisees un proxy de un valor que no necesariamente se conoce cuando se crea la promesa.
        Le permite asociar controladores con el valor eventual de 茅xito o el motivo de falla de una acci贸n as铆ncrona. Esto permite que los m茅todos as铆ncronos devuelvan valores como los m茅todos s铆ncronos: en lugar de devolver inmediatamente el valor final, el m茅todo as铆ncrono devuelve la promesa de proporcionar el valor en alg煤n momento en el futuro.

        A Promiseest谩 en uno de estos estados:

<b> <i>pendiente : </i></b>  estado inicial, ni cumplida ni rechazada.
<b> <i>cumplida : </i></b>  lo que significa que la operaci贸n se complet贸 con 茅xito.
<b> <i>rechazado : </i></b> lo que significa que la operaci贸n fall贸.

 El estado eventual de una promesa pendiente puede cumplirse con un valor o rechazarse con una raz贸n (error).
Cuando ocurre alguna de estas opciones, thense llama a los controladores asociados en cola por el m茅todo de una promesa.
Si la promesa ya se ha cumplido o rechazado cuando se adjunta un controlador correspondiente, se llamar谩 al controlador,
por lo que no existe una condici贸n de carrera entre la finalizaci贸n de una operaci贸n as铆ncrona y la conexi贸n de sus controladores.

Se dice que una promesa est谩 liquidada si se cumple o se rechaza, pero no est谩 pendiente.
        </pre></p>

        <h2>Async / Await</h2>

        <p><pre>
            Las promesas fueron una gran mejora respecto a las callbacks para controlar la asincron铆a en JavaScript, 
            sin embargo pueden llegar a ser muy verbosas a medida que se requieran m谩s y m谩s m茅todos .then().

Las funciones as铆ncronas (async / await) surgen para simplificar el manejo de las promesas.

La palabra async declara una funci贸n como as铆ncrona e indica que una promesa ser谩 autom谩ticamente devuelta.

Podemos declarar como async funciones con nombre, an贸nimas o funciones flecha.

La palabra await debe ser usado siempre dentro de una funci贸n declarada como async y esperar谩 de forma as铆ncrona y 
no bloqueante a que una promesa se resuelva o rechace.
        </pre></p>

        <script>
         /* **********     Curso JavaScript: 45. Asincron铆a y el Event Loop - #jonmircha     ********** */            // POO PROGRAMACION ORIENTADA A OBJETOS
           
        /*console.log("Inicio");
        setTimeout(() => {
            console.log("Ejecutando un setTimeout, eso se ejecuta una s贸la vez.")
        }, 3000);    
            

        setInterval(() => {
            console.log("Ejecuntando un setInterval, esto se ejecuta indefinidamente cada cierto intervalo de tiempo.")
        }, 3000);

        let temporizador = setInterval(() => {
            console.log(new Date().toLocaleTimeString())
        }, 1000);

        clearInterval(temporizador);
        console.log("despues del clearInterval");
*/


    // Codigo S铆ncrono Bloqueante

       /* (() => {
            console.log("Codigo S铆ncrono");
            console.log("Inicio");

            function dos() {
                console.log("Dos");
            }

            function uno() {
                console.log("Uno");
                dos();
                console.log("Tres");
            }

            uno();
            console.log("Fin");

        })();

        console.log("^^^^^^^^^^^^")

    // Codigo As铆ncrono No Bloqueante

        (() => {
            console.log("Codigo As铆ncrono");
            console.log("Inicio");

            function dos() {
                setTimeout(function() {
                   console.log("Dos"); 
                },1000);
                
            }

            function uno() {
                setTimeout(function() {
                    console.log("Uno");
                    
                },0)
                dos();
                    console.log("Tres");   
            }

            uno();
            console.log("Fin");
        })();
*/

        /* **********     Curso JavaScript: 46. Callbacks - #jonmircha     ********** */
        
        /*
        function cuadradoCallback(value, callback) {
            setTimeout(() => {
                callback(value, value * value);
            }, 0 | Math.random()*1000   );
        }

        cuadradoCallback(0, (value, result) => {
            console.log("Inicia Callback");
            console.log(`Callback: ${value}, ${result}`);

            cuadradoCallback(1, (value, result) => {
                console.log(`Callback: ${value}, ${result}`);
                
                cuadradoCallback(2, (value, result) => {
                    console.log(`Callback: ${value}, ${result}`);
                    
                    cuadradoCallback(3, (value, result) => {
                        console.log(`Callback: ${value}, ${result}`);
                        
                        cuadradoCallback(4, (value, result) => {
                            console.log(`Callback: ${value}, ${result}`);
                            
                            cuadradoCallback(5, (value, result) => {
                                console.log(`Callback: ${value}, ${result}`);
                                console.log("Fin Callback");
                                console.log("Callback Hell !!!!!");
                                console.log("http://callbackhell.com/"); 
                            });
                        });
                    });
                });
            });
        });
        
        */
        /* **********     Curso JavaScript: 47. Promesas - #jonmircha     ********** */
        
        /*function cuadradoPromise(value) {
            if(typeof value !== 'number') {
                return Promise.reject(`Error, el valor "${value}" ingresado, NO es un numero.`);
            }
            
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve({
                        value,
                        result: value * value
                    });
                },0 | Math.random()*1000);
            });
        }

        cuadradoPromise(0)
            .then(obj => {
                console.log("Inicio Promise");
                console.log(`Promise: ${obj.value}, ${obj.result}`);
                return cuadradoPromise(1);
            })
            .then(obj => {
                console.log(`Promise: ${obj.value}, ${obj.result}`);
                return cuadradoPromise(2);
            })
            .then(obj => {
                console.log(`Promise: ${obj.value}, ${obj.result}`);
                return cuadradoPromise("3");
            })
            .then(obj => {
                console.log(`Promise: ${obj.value}, ${obj.result}`);
                return cuadradoPromise(4);
            })
            .then(obj => {
                console.log(`Promise: ${obj.value}, ${obj.result}`);
                return cuadradoPromise(5);
            })
            .then(obj => {
                console.log(`Promise: ${obj.value}, ${obj.result}`);
                console.log("Fin Promise.");
            })
            .catch(err => console.error(err));
        */

        /* **********     Curso JavaScript: 48. Async - Await - #jonmircha     ********** */

        function cuadradoPromise(value) {
            if (typeof value !== "number") {
                return Promise.reject(`Error, el valor " ${value} " ingresado no es un n煤mero`);
            }

            return new Promise((resolve, reject) => {
                setTimeout(() => {
                resolve({
                    value,
                    result: value * value
                });
                }, 0 | Math.random() * 1000);
            });
        }

        async function funcionAsincronaDeclarada () {
            try {
                console.log("Inicio Async Function");
                
                let obj = await cuadradoPromise(0);
                console.log(`Async Function: ${obj.value}, ${obj.result}`);

                obj = await cuadradoPromise(1);
                console.log(`Async Function: ${obj.value}, ${obj.result}`);

                obj = await cuadradoPromise(2);
                console.log(`Async Function: ${obj.value}, ${obj.result}`);

                obj = await cuadradoPromise(3);
                console.log(`Async Function: ${obj.value}, ${obj.result}`);

                obj = await cuadradoPromise(4);
                console.log(`Async Function: ${obj.value}, ${obj.result}`);

                obj = await cuadradoPromise(5);
                console.log(`Async Function: ${obj.value}, ${obj.result}`);

                console.log('Fin Async Function');
            } catch (error) {
                console.error(error)
            }
        }

        funcionAsincronaDeclarada();

        const funcionAsincronaExpresada = async() => {
            try {
                console.log('Inicio Async Function');
                let obj = await cuadradoPromise(6);
                console.log(`Async Function: ${obj.value}, ${obj.result}`);
                obj = await cuadradoPromise(7);
                console.log(`Async Function: ${obj.value}, ${obj.result}`);
                obj = await cuadradoPromise(8);
                console.log(`Async Function: ${obj.value}, ${obj.result}`);
                obj = await cuadradoPromise("9");
                console.log(`Async Function: ${obj.value}, ${obj.result}`);
                obj = await cuadradoPromise(10);
                console.log(`Async Function: ${obj.value}, ${obj.result}`);
                
                console.log('Fin Async Function');
            } catch (err) {
                console.error(err)
            }
        }

        funcionAsincronaExpresada();






        </script>
    </body>
</html>